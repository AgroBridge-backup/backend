/**
 * Vulnerability Scanner
 * Security checks, dependency audits, and configuration validation
 */

import { execSync } from "child_process";
import fs from "fs";
import path from "path";
import { logger } from "../logging/logger.js";

/**
 * Vulnerability severity levels
 */
export enum VulnerabilitySeverity {
  INFO = "INFO",
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
  CRITICAL = "CRITICAL",
}

/**
 * Vulnerability finding
 */
export interface VulnerabilityFinding {
  id: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  category: string;
  remediation?: string;
  references?: string[];
  affectedComponent?: string;
  cwe?: string;
  cvss?: number;
}

/**
 * Scan result
 */
export interface ScanResult {
  scanId: string;
  timestamp: Date;
  duration: number;
  findings: VulnerabilityFinding[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  passed: boolean;
}

/**
 * Security configuration checks
 */
const SECURITY_CHECKS = {
  // Environment variable checks
  envVars: {
    required: [
      "DATABASE_URL",
      "JWT_ACCESS_SECRET",
      "JWT_REFRESH_SECRET",
      "ENCRYPTION_KEY",
    ],
    sensitive: [
      "DATABASE_URL",
      "JWT_ACCESS_SECRET",
      "JWT_REFRESH_SECRET",
      "ENCRYPTION_KEY",
      "AWS_SECRET_ACCESS_KEY",
      "STRIPE_SECRET_KEY",
      "SENDGRID_API_KEY",
    ],
  },

  // Security headers
  headers: {
    required: [
      "X-Content-Type-Options",
      "X-Frame-Options",
      "X-XSS-Protection",
      "Strict-Transport-Security",
      "Content-Security-Policy",
    ],
  },

  // Dangerous patterns in code
  dangerousPatterns: [
    {
      pattern: /eval\s*\(/,
      message: "Use of eval() detected",
      severity: VulnerabilitySeverity.CRITICAL,
    },
    {
      pattern: /exec\s*\(/,
      message: "Use of exec() detected",
      severity: VulnerabilitySeverity.HIGH,
    },
    {
      pattern: /child_process/,
      message: "Use of child_process detected",
      severity: VulnerabilitySeverity.MEDIUM,
    },
    {
      pattern: /innerHTML\s*=/,
      message: "Use of innerHTML detected",
      severity: VulnerabilitySeverity.HIGH,
    },
    {
      pattern: /document\.write/,
      message: "Use of document.write detected",
      severity: VulnerabilitySeverity.HIGH,
    },
    {
      pattern: /SELECT.*\+.*WHERE/,
      message: "Potential SQL injection",
      severity: VulnerabilitySeverity.CRITICAL,
    },
    {
      pattern: /password\s*[:=]\s*['"][^'"]+['"]/,
      message: "Hardcoded password detected",
      severity: VulnerabilitySeverity.CRITICAL,
    },
    {
      pattern: /api[_-]?key\s*[:=]\s*['"][^'"]+['"]/,
      message: "Hardcoded API key detected",
      severity: VulnerabilitySeverity.CRITICAL,
    },
    {
      pattern: /secret\s*[:=]\s*['"][^'"]+['"]/,
      message: "Hardcoded secret detected",
      severity: VulnerabilitySeverity.CRITICAL,
    },
    {
      pattern: /\$\{.*\}.*query/,
      message: "Potential template injection in query",
      severity: VulnerabilitySeverity.HIGH,
    },
  ],
};

/**
 * Vulnerability Scanner class
 */
export class VulnerabilityScanner {
  private findings: VulnerabilityFinding[] = [];
  private scanId: string;

  constructor() {
    this.scanId = `scan_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  }

  /**
   * Run full security scan
   */
  async runFullScan(): Promise<ScanResult> {
    const startTime = Date.now();
    this.findings = [];

    logger.info("Starting security scan", { scanId: this.scanId });

    // Run all checks
    await this.checkEnvironmentVariables();
    await this.checkDependencies();
    await this.checkCodePatterns();
    await this.checkSecurityConfiguration();
    await this.checkFilePermissions();
    await this.checkSensitiveDataExposure();

    const duration = Date.now() - startTime;

    const summary = this.calculateSummary();
    const passed = summary.critical === 0 && summary.high === 0;

    const result: ScanResult = {
      scanId: this.scanId,
      timestamp: new Date(),
      duration,
      findings: this.findings,
      summary,
      passed,
    };

    logger.info("Security scan completed", {
      scanId: this.scanId,
      duration,
      passed,
      summary,
    });

    return result;
  }

  /**
   * Check environment variables
   */
  private async checkEnvironmentVariables(): Promise<void> {
    // Check for required variables
    for (const varName of SECURITY_CHECKS.envVars.required) {
      if (!process.env[varName]) {
        this.addFinding({
          id: `ENV_MISSING_${varName}`,
          title: `Missing required environment variable: ${varName}`,
          description: `The environment variable ${varName} is required but not set`,
          severity: VulnerabilitySeverity.CRITICAL,
          category: "Configuration",
          remediation: `Set the ${varName} environment variable`,
        });
      }
    }

    // Check for weak secrets
    for (const varName of SECURITY_CHECKS.envVars.sensitive) {
      const value = process.env[varName];
      if (value) {
        if (value.length < 32) {
          this.addFinding({
            id: `ENV_WEAK_${varName}`,
            title: `Weak secret: ${varName}`,
            description: `The secret ${varName} appears to be too short (less than 32 characters)`,
            severity: VulnerabilitySeverity.HIGH,
            category: "Configuration",
            remediation: `Use a stronger secret with at least 32 characters`,
          });
        }

        // Check for common weak values
        const weakValues = ["password", "secret", "123456", "admin", "test"];
        if (weakValues.some((w) => value.toLowerCase().includes(w))) {
          this.addFinding({
            id: `ENV_WEAK_VALUE_${varName}`,
            title: `Potentially weak value for ${varName}`,
            description: `The value contains common weak patterns`,
            severity: VulnerabilitySeverity.HIGH,
            category: "Configuration",
            remediation: `Use a cryptographically random value`,
          });
        }
      }
    }

    // Check NODE_ENV
    if (process.env.NODE_ENV !== "production") {
      this.addFinding({
        id: "ENV_NOT_PRODUCTION",
        title: "Not running in production mode",
        description: "NODE_ENV is not set to production",
        severity: VulnerabilitySeverity.INFO,
        category: "Configuration",
        remediation: "Set NODE_ENV=production in production environments",
      });
    }
  }

  /**
   * Check dependencies for vulnerabilities
   */
  private async checkDependencies(): Promise<void> {
    try {
      const auditOutput = execSync("npm audit --json 2>/dev/null || true", {
        encoding: "utf8",
        maxBuffer: 10 * 1024 * 1024,
      });

      if (auditOutput) {
        const audit = JSON.parse(auditOutput);

        if (audit.vulnerabilities) {
          for (const [name, vuln] of Object.entries(audit.vulnerabilities)) {
            const v = vuln as any;
            this.addFinding({
              id: `DEP_${name.toUpperCase().replace(/[^A-Z0-9]/g, "_")}`,
              title: `Vulnerable dependency: ${name}`,
              description: `${v.severity} vulnerability in ${name}`,
              severity: this.mapNpmSeverity(v.severity),
              category: "Dependencies",
              remediation: v.fixAvailable
                ? "Run npm audit fix"
                : "Update or replace the package",
              affectedComponent: name,
            });
          }
        }
      }
    } catch (error) {
      logger.warn("Failed to run npm audit", { error });
    }
  }

  /**
   * Check code for dangerous patterns
   */
  private async checkCodePatterns(): Promise<void> {
    const srcDir = path.join(process.cwd(), "src");

    if (!fs.existsSync(srcDir)) {
      return;
    }

    const files = this.getFilesRecursive(srcDir, [".ts", ".js"]);

    for (const file of files) {
      try {
        const content = fs.readFileSync(file, "utf8");
        const relativePath = path.relative(process.cwd(), file);

        for (const check of SECURITY_CHECKS.dangerousPatterns) {
          if (check.pattern.test(content)) {
            this.addFinding({
              id: `CODE_PATTERN_${check.message.replace(/\s+/g, "_").toUpperCase()}`,
              title: check.message,
              description: `Dangerous pattern found in ${relativePath}`,
              severity: check.severity,
              category: "Code Quality",
              affectedComponent: relativePath,
              remediation: "Review and refactor the code to avoid this pattern",
            });
          }
        }
      } catch (error) {
        // Skip files that can't be read
      }
    }
  }

  /**
   * Check security configuration
   */
  private async checkSecurityConfiguration(): Promise<void> {
    // Check for .env file in version control
    const gitIgnorePath = path.join(process.cwd(), ".gitignore");
    if (fs.existsSync(gitIgnorePath)) {
      const gitignore = fs.readFileSync(gitIgnorePath, "utf8");
      if (!gitignore.includes(".env")) {
        this.addFinding({
          id: "CONFIG_ENV_NOT_GITIGNORED",
          title: ".env file not in .gitignore",
          description: "The .env file should be excluded from version control",
          severity: VulnerabilitySeverity.HIGH,
          category: "Configuration",
          remediation: "Add .env to .gitignore",
        });
      }
    }

    // Check for debug mode
    if (process.env.DEBUG === "true" || process.env.DEBUG === "*") {
      this.addFinding({
        id: "CONFIG_DEBUG_ENABLED",
        title: "Debug mode enabled",
        description: "Debug mode should be disabled in production",
        severity: VulnerabilitySeverity.MEDIUM,
        category: "Configuration",
        remediation:
          "Disable debug mode by removing DEBUG environment variable",
      });
    }

    // Check CORS configuration
    const corsOrigin = process.env.CORS_ORIGIN;
    if (corsOrigin === "*") {
      this.addFinding({
        id: "CONFIG_CORS_WILDCARD",
        title: "CORS allows all origins",
        description:
          "Using wildcard CORS origin allows requests from any domain",
        severity: VulnerabilitySeverity.MEDIUM,
        category: "Configuration",
        remediation: "Restrict CORS to specific trusted domains",
      });
    }

    // Check rate limiting
    if (
      !process.env.RATE_LIMIT_ENABLED ||
      process.env.RATE_LIMIT_ENABLED === "false"
    ) {
      this.addFinding({
        id: "CONFIG_NO_RATE_LIMIT",
        title: "Rate limiting not enabled",
        description: "Rate limiting should be enabled to prevent abuse",
        severity: VulnerabilitySeverity.MEDIUM,
        category: "Configuration",
        remediation: "Enable rate limiting",
      });
    }
  }

  /**
   * Check file permissions
   */
  private async checkFilePermissions(): Promise<void> {
    const sensitiveFiles = [
      ".env",
      ".env.production",
      "private.key",
      "secrets.json",
    ];

    for (const file of sensitiveFiles) {
      const filePath = path.join(process.cwd(), file);
      if (fs.existsSync(filePath)) {
        try {
          const stats = fs.statSync(filePath);
          const mode = (stats.mode & 0o777).toString(8);

          // Check if file is readable by others
          if (
            mode.endsWith("4") ||
            mode.endsWith("5") ||
            mode.endsWith("6") ||
            mode.endsWith("7")
          ) {
            this.addFinding({
              id: `FILE_PERMISSIONS_${file.replace(/\./g, "_").toUpperCase()}`,
              title: `Sensitive file has insecure permissions: ${file}`,
              description: `File ${file} is readable by others (mode: ${mode})`,
              severity: VulnerabilitySeverity.HIGH,
              category: "File System",
              remediation: `Run: chmod 600 ${file}`,
            });
          }
        } catch (error) {
          // Skip if can't read stats
        }
      }
    }
  }

  /**
   * Check for sensitive data exposure
   */
  private async checkSensitiveDataExposure(): Promise<void> {
    // Check if package.json exposes sensitive info
    const packageJsonPath = path.join(process.cwd(), "package.json");
    if (fs.existsSync(packageJsonPath)) {
      try {
        const pkg = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));

        // Check for private registry credentials
        if (pkg.publishConfig?.registry?.includes("@")) {
          this.addFinding({
            id: "PKG_REGISTRY_CREDS",
            title: "Package.json may contain registry credentials",
            description:
              "The publishConfig.registry field may contain credentials",
            severity: VulnerabilitySeverity.HIGH,
            category: "Configuration",
            remediation: "Use .npmrc for registry authentication",
          });
        }
      } catch (error) {
        // Skip if can't parse
      }
    }

    // Check for exposed secrets in logs
    const logsDir = path.join(process.cwd(), "logs");
    if (fs.existsSync(logsDir)) {
      const logFiles = fs
        .readdirSync(logsDir)
        .filter((f) => f.endsWith(".log"));
      for (const logFile of logFiles.slice(0, 5)) {
        // Check first 5 log files
        try {
          const content = fs.readFileSync(path.join(logsDir, logFile), "utf8");
          const sensitivePatterns = [
            /password['":\s]+[^,\s]+/gi,
            /api[_-]?key['":\s]+[^,\s]+/gi,
            /secret['":\s]+[^,\s]+/gi,
            /token['":\s]+eyJ[A-Za-z0-9_-]+/gi,
          ];

          for (const pattern of sensitivePatterns) {
            if (pattern.test(content)) {
              this.addFinding({
                id: "LOG_SENSITIVE_DATA",
                title: "Potential sensitive data in logs",
                description: `Log file ${logFile} may contain sensitive information`,
                severity: VulnerabilitySeverity.HIGH,
                category: "Data Exposure",
                remediation:
                  "Review logging configuration to mask sensitive data",
              });
              break;
            }
          }
        } catch (error) {
          // Skip if can't read
        }
      }
    }
  }

  /**
   * Add a finding
   */
  private addFinding(finding: VulnerabilityFinding): void {
    // Avoid duplicates
    if (!this.findings.some((f) => f.id === finding.id)) {
      this.findings.push(finding);
    }
  }

  /**
   * Calculate summary
   */
  private calculateSummary(): ScanResult["summary"] {
    return {
      total: this.findings.length,
      critical: this.findings.filter(
        (f) => f.severity === VulnerabilitySeverity.CRITICAL,
      ).length,
      high: this.findings.filter(
        (f) => f.severity === VulnerabilitySeverity.HIGH,
      ).length,
      medium: this.findings.filter(
        (f) => f.severity === VulnerabilitySeverity.MEDIUM,
      ).length,
      low: this.findings.filter((f) => f.severity === VulnerabilitySeverity.LOW)
        .length,
      info: this.findings.filter(
        (f) => f.severity === VulnerabilitySeverity.INFO,
      ).length,
    };
  }

  /**
   * Map npm audit severity to our severity
   */
  private mapNpmSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toLowerCase()) {
      case "critical":
        return VulnerabilitySeverity.CRITICAL;
      case "high":
        return VulnerabilitySeverity.HIGH;
      case "moderate":
        return VulnerabilitySeverity.MEDIUM;
      case "low":
        return VulnerabilitySeverity.LOW;
      default:
        return VulnerabilitySeverity.INFO;
    }
  }

  /**
   * Get files recursively
   */
  private getFilesRecursive(dir: string, extensions: string[]): string[] {
    const files: string[] = [];

    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        // Skip node_modules and hidden directories
        if (
          entry.name.startsWith(".") ||
          entry.name === "node_modules" ||
          entry.name === "dist"
        ) {
          continue;
        }

        if (entry.isDirectory()) {
          files.push(...this.getFilesRecursive(fullPath, extensions));
        } else if (extensions.some((ext) => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Skip directories we can't read
    }

    return files;
  }
}

/**
 * Generate HTML report
 */
export function generateHtmlReport(result: ScanResult): string {
  const severityColors: Record<VulnerabilitySeverity, string> = {
    [VulnerabilitySeverity.CRITICAL]: "#dc3545",
    [VulnerabilitySeverity.HIGH]: "#fd7e14",
    [VulnerabilitySeverity.MEDIUM]: "#ffc107",
    [VulnerabilitySeverity.LOW]: "#17a2b8",
    [VulnerabilitySeverity.INFO]: "#6c757d",
  };

  const findingsHtml = result.findings
    .sort((a, b) => {
      const order = [
        VulnerabilitySeverity.CRITICAL,
        VulnerabilitySeverity.HIGH,
        VulnerabilitySeverity.MEDIUM,
        VulnerabilitySeverity.LOW,
        VulnerabilitySeverity.INFO,
      ];
      return order.indexOf(a.severity) - order.indexOf(b.severity);
    })
    .map(
      (f) => `
      <div class="finding" style="border-left: 4px solid ${severityColors[f.severity]}; padding: 10px; margin: 10px 0; background: #f8f9fa;">
        <h4 style="margin: 0;">${f.title}</h4>
        <span style="background: ${severityColors[f.severity]}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${f.severity}</span>
        <span style="background: #e9ecef; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 5px;">${f.category}</span>
        <p>${f.description}</p>
        ${f.remediation ? `<p><strong>Remediation:</strong> ${f.remediation}</p>` : ""}
        ${f.affectedComponent ? `<p><strong>Affected:</strong> ${f.affectedComponent}</p>` : ""}
      </div>
    `,
    )
    .join("");

  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Security Scan Report - ${result.scanId}</title>
      <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .summary-card { padding: 20px; border-radius: 8px; color: white; text-align: center; }
        h1 { color: #333; }
      </style>
    </head>
    <body>
      <h1>Security Scan Report</h1>
      <p><strong>Scan ID:</strong> ${result.scanId}</p>
      <p><strong>Date:</strong> ${result.timestamp.toISOString()}</p>
      <p><strong>Duration:</strong> ${result.duration}ms</p>
      <p><strong>Status:</strong> ${result.passed ? "✅ PASSED" : "❌ FAILED"}</p>

      <h2>Summary</h2>
      <div class="summary">
        <div class="summary-card" style="background: ${severityColors.CRITICAL}">
          <h3>${result.summary.critical}</h3>
          <p>Critical</p>
        </div>
        <div class="summary-card" style="background: ${severityColors.HIGH}">
          <h3>${result.summary.high}</h3>
          <p>High</p>
        </div>
        <div class="summary-card" style="background: ${severityColors.MEDIUM}">
          <h3>${result.summary.medium}</h3>
          <p>Medium</p>
        </div>
        <div class="summary-card" style="background: ${severityColors.LOW}">
          <h3>${result.summary.low}</h3>
          <p>Low</p>
        </div>
        <div class="summary-card" style="background: ${severityColors.INFO}">
          <h3>${result.summary.info}</h3>
          <p>Info</p>
        </div>
      </div>

      <h2>Findings (${result.findings.length})</h2>
      ${findingsHtml || "<p>No findings</p>"}
    </body>
    </html>
  `;
}

// Singleton instance
let scannerInstance: VulnerabilityScanner | null = null;

/**
 * Get vulnerability scanner instance
 */
export function getVulnerabilityScanner(): VulnerabilityScanner {
  if (!scannerInstance) {
    scannerInstance = new VulnerabilityScanner();
  }
  return scannerInstance;
}

export default {
  VulnerabilityScanner,
  getVulnerabilityScanner,
  generateHtmlReport,
  VulnerabilitySeverity,
};
